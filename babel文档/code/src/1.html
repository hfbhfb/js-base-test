<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      console.log('111')

      var CompassDirection
      ;(function (CompassDirection) {
        CompassDirection[(CompassDirection['North'] = 0)] = 'North'
        CompassDirection[(CompassDirection['East'] = 1)] = 'East'
        CompassDirection[(CompassDirection['South'] = 2)] = 'South'
        CompassDirection[(CompassDirection['West'] = 3)] = 'West'
      })(CompassDirection || (CompassDirection = {}))

      // function Person() {}
      // Person.prototype.name = 'Kevin'
      // var person = new Person()
      // person.name = 'Daisy'
      // console.log(person.name) // Daisy
      // console.log(person)
      // delete person.name
      // console.log(person.name) // Kevin
      // console.log(person)

      // function Person() {}
      // var person = new Person()
      // console.log(person.__proto__ == Person.prototype) // true
      // console.log(Person.prototype.constructor == Person) // true
      // // 顺便学习一个ES5的方法,可以获得对象的原型
      // console.log(Object.getPrototypeOf(person) === Person.prototype) // true
      // console.log(person)
      // console.log(Person)

      // a = '111'
      // console.log(typeof a)
      // console.log(a)
      // b = new String('111')
      // console.log(String(b))
      // console.log(b)

      // function copyInstanceof(source, target) {
      //   // 基本数据类型以及 null 直接返回 false
      //   if (!['function', 'object'].includes(typeof source) || source === null) return false
      //   // getProtypeOf 是 Object 对象自带的一个方法，能够拿到参数的原型对象
      //   let proto = Object.getPrototypeOf(source)
      //   while (true) {
      //     // 查找到尽头，还没找到
      //     if (proto == null) return false
      //     // 找到相同的原型对象
      //     if (proto == target.prototype) return true
      //     proto = Object.getPrototypeOf(proto)
      //   }
      // }
      // console.log(copyInstanceof('111', String)) // false
      // console.log(copyInstanceof(new String('111'), String)) // true
      // console.log(copyInstanceof(Date, Function)) // true
      // console.log(copyInstanceof(null, Object)) // false

      // function aa() {
      //   return (
      //     (_b = () => {
      //       return 1
      //     }),
      //     _b(),
      //     (() => {
      //       return 2
      //     })()
      //   )
      // }
      // console.log(aa()) // 1  因为最后执行了  _b()

      // function _typeof(obj) {
      //   '@babel/helpers - typeof'
      //   return (
      //     (_typeof =
      //       'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      //         ? function (obj) {
      //             return typeof obj
      //           }
      //         : function (obj) {
      //             return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
      //               ? 'symbol'
      //               : typeof obj
      //           }),
      //     _typeof(obj)
      //   )
      // }
      // function _defineProperties(target, props) {
      //   for (var i = 0; i < props.length; i++) {
      //     var descriptor = props[i]
      //     descriptor.enumerable = descriptor.enumerable || false
      //     descriptor.configurable = true
      //     if ('value' in descriptor) descriptor.writable = true
      //     Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
      //   }
      // }
      // function _createClass(Constructor, protoProps, staticProps) {
      //   if (protoProps) _defineProperties(Constructor.prototype, protoProps)
      //   if (staticProps) _defineProperties(Constructor, staticProps)
      //   Object.defineProperty(Constructor, 'prototype', { writable: false })
      //   return Constructor
      // }
      // function _classCallCheck(instance, Constructor) {
      //   if (!(instance instanceof Constructor)) {
      //     throw new TypeError('Cannot call a class as a function')
      //   }
      // }
      // function _defineProperty(obj, key, value) {
      //   key = _toPropertyKey(key)
      //   if (key in obj) {
      //     Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true })
      //   } else {
      //     obj[key] = value
      //   }
      //   return obj
      // }
      // function _toPropertyKey(arg) {
      //   var key = _toPrimitive(arg, 'string')
      //   return _typeof(key) === 'symbol' ? key : String(key)
      // }
      // function _toPrimitive(input, hint) {
      //   if (_typeof(input) !== 'object' || input === null) return input
      //   var prim = input[Symbol.toPrimitive]
      //   if (prim !== undefined) {
      //     var res = prim.call(input, hint || 'default')
      //     if (_typeof(res) !== 'object') return res
      //     throw new TypeError('@@toPrimitive must return a primitive value.')
      //   }
      //   return (hint === 'string' ? String : Number)(input)
      // }
      // var Ca = /*#__PURE__*/ _createClass(function Ca(executor) {
      //   _classCallCheck(this, Ca)
      //   _defineProperty(this, 'state', 0)
      //   this.state = 2
      // })
      // a = new Ca()
      // console.log(a)

      // class Ca {
      //   state = 0
      //   constructor(executor) {
      //     this.state = 2
      //   }
      // }
      // a = new Ca()
      // console.log(a)

      //   var name = '有鱼'
      //   function eat() {
      //     console.log(this.name)
      //   }
      //   var cat = {
      //     name: '年年',
      //   }
      //   var dog = {
      //     name: '高飞',
      //   }

      //   eat.call(cat) // 年年
      //   eat.call(dog) // 高飞
      //   function aaa() {
      //     function bbb() {
      //       console.log(this)
      //       console.log('444')
      //       //console.log(aaa())
      //     }
      //     console.log('333')
      //     bbb()
      //     console.log(this)
      //     return this
      //   }
      //   c = aaa()
      //   console.log(this)
      //   console.log(c)

      //   console.log(c)
      //   console.log(aaa)
      //   // 数值
      //   typeof 37 === 'number'
      //   typeof 3.14 === 'number'
      //   typeof 42 === 'number'
      //   typeof Math.LN2 === 'number'
      //   typeof Infinity === 'number'
      //   typeof NaN === 'number' // 尽管它是 "Not-A-Number" (非数值) 的缩写
      //   typeof Number(1) === 'number' // Number 会尝试把参数解析成数值

      //   typeof 42n === 'bigint'

      //   // 字符串
      //   typeof '' === 'string'
      //   typeof 'bla' === 'string'
      //   typeof `template literal` === 'string'
      //   typeof '1' === 'string' // 注意内容为数字的字符串仍是字符串
      //   typeof typeof 1 === 'string' // typeof 总是返回一个字符串
      //   typeof String(1) === 'string' // String 将任意值转换为字符串，比 toString 更安全

      //   // 布尔值
      //   typeof true === 'boolean'
      //   typeof false === 'boolean'
      //   typeof Boolean(1) === 'boolean' // Boolean() 会基于参数是真值还是虚值进行转换
      //   typeof !!1 === 'boolean' // 两次调用 ! (逻辑非) 操作符相当于 Boolean()

      //   // Symbols
      //   typeof Symbol() === 'symbol'
      //   typeof Symbol('foo') === 'symbol'
      //   typeof Symbol.iterator === 'symbol'

      //   // Undefined
      //   typeof undefined === 'undefined'
      //   typeof declaredButUndefinedVariable === 'undefined'
      //   typeof undeclaredVariable === 'undefined'

      //   // 对象
      //   typeof { a: 1 } === 'object'

      //   // 使用 Array.isArray 或者 Object.prototype.toString.call
      //   // 区分数组和普通对象
      //   console.log(typeof [1, 2, 4] === 'object')

      //   typeof new Date() === 'object'
      //   typeof /regex/ === 'object' // 历史结果请参阅正则表达式部分

      //   // 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。
      //   typeof new Boolean(true) === 'object'
      //   typeof new Number(1) === 'object'
      //   typeof new String('abc') === 'object'

      //   // 函数
      //   typeof function () {} === 'function'
      //   typeof class C {} === 'function'
      //   typeof Math.sin === 'function'

      //   let _password = Symbol('password')
      //   const obj = {
      //     name: '小明',
      //     gender: 'male',
      //     [_password]: '11038',
      //   }
      //   for (let item in obj) {
      //     console.log(item)
      //   }
      //   console.log(Object.keys(obj))
      //   console.log(Object.values(obj))
      //   console.log(Object.getOwnPropertyNames(obj))
      //   console.log(Object.getOwnPropertySymbols(obj))
      //   console.log(Reflect.ownKeys(obj))
      //   // 输出11038，所以还是可以直接访问到symbol类型的属性，所以symbol并不能真正实现私有变量的设定，所以一般只用于定义一些非私有的、但又希望只用于内部的方法
      //   console.log(obj[_password])
      //   console.log(obj)

      //   //后面的括号可以给symbol做上标记便于识别
      //   let name = Symbol('name')
      //   let say = Symbol('say')
      //   console.log(name)
      //   console.log(say)
      //   let obj = {
      //     //如果想 使用变量作为对象属性的名称，必须加上中括号，.运算符后面跟着的都是字符串
      //     [name]: 'lnj',
      //     [say]: function () {
      //       console.log('say')
      //     },
      //   }
      //   obj.name = 'it666'
      //   obj[Symbol('name')] = 'it666'
      //   console.log(obj)

      //   function _typeof(obj) {
      //     '@babel/helpers - typeof'
      //     return (
      //       (_typeof =
      //         'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      //           ? function (obj) {
      //               return typeof obj
      //             }
      //           : function (obj) {
      //               return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
      //                 ? 'symbol'
      //                 : typeof obj
      //             }),
      //       _typeof(obj)
      //     )
      //   }
      //   _bbb = () => {
      //     console.log('777'), console.log('888')
      //   }
      //   console.log(_typeof('111'))
      //   console.log(_typeof(() => {})),
      //     ((_aaa = () => {
      //       console.log('555'), console.log('666')
      //     }),
      //     console.log('333'),
      //     console.log('444'),
      //     _aaa(),
      //     _bbb())
      //   console.log('111'), console.log('222')
    </script>
  </body>
</html>
